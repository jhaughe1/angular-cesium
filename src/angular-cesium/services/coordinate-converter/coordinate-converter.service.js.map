{"version":3,"sources":["coordinate-converter.service.ts"],"names":[],"mappings":"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","file":"coordinate-converter.service.js","sourceRoot":"","sourcesContent":["import { Injectable, Optional } from '@angular/core';\r\nimport { CesiumService } from '../cesium/cesium.service';\r\nimport * as geodesy from 'geodesy';\r\nimport {hemisphere, LatLon, LatLonEllipsoidal, Utm} from 'geodesy';\r\nimport { Cartesian3 } from '../../models/cartesian3';\r\n\r\nconst LatLonVectors = geodesy['LatLonVectors']; // doesnt exists on typings\r\n\r\nwindow['geodesy'] = geodesy;\r\n\r\n/**\r\n *  Given different types of coordinates, we provide you a service converting those types to the most common other types.\r\n *  We are using the geodesy implementation of UTM conversion. see: https://github.com/chrisveness/geodesy.\r\n *\r\n * @example\r\n * import { Component, OnInit } from '@angular/core';\r\n * import { CoordinateConverter } from 'angular2-cesium';\r\n *\r\n * @Component({\r\n * \t\tselector:'my-component',\r\n * \t\ttemplate:'<div>{{showCartographic}}</div>',\r\n * \t\tproviders:[CoordinateConverter]\r\n * })\r\n * export class MyComponent implements OnInit {\r\n * \t\tshowCartographic;\r\n *\r\n * \t\tconstructor(private coordinateConverter:CoordinateConverter){\r\n * \t\t}\r\n *\r\n * \t\tngOnInit(){\r\n * \t\t\tthis.showCartographic = this.coordinateConverter.degreesToCartographic(5, 5, 5);\r\n *  }\r\n * }\r\n *\r\n */\r\n\r\nexport class CoordinateConverter {\r\n\tconstructor( private cesiumService?: CesiumService) {\r\n\t}\r\n\t\r\n\tscreenToCartesian3(screenPos: { x: number, y: number }, addMapCanvansBoundsToPos?: boolean) {\r\n\t\tif (!this.cesiumService) {\r\n\t\t\tthrow new Error('ANGULAR2-CESIUM - Cesium service should be provided in order to do screen position calculations');\r\n\t\t}\r\n\t\telse {\r\n\t\t\tconst screenPosition = {...screenPos};\r\n\t\t\tif (addMapCanvansBoundsToPos) {\r\n\t\t\t\tconst mapBounds = this.cesiumService.getViewer().canvas.getBoundingClientRect();\r\n\t\t\t\tscreenPosition.x += mapBounds.left;\r\n\t\t\t\tscreenPosition.y += mapBounds.top;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst camera = this.cesiumService.getViewer().camera;\r\n\t\t\treturn camera.pickEllipsoid(screenPosition);\r\n\t\t}\r\n\t}\r\n\t\r\n\tscreenToCartographic(screenPos: { x: number, y: number }, ellipsoid?: any) {\r\n\t\treturn this.cartesian3ToCartographic(this.screenToCartesian3(screenPos), ellipsoid);\r\n\t}\r\n\t\r\n\tcartesian3ToCartographic(cartesian: Cartesian3, ellipsoid?: any) {\r\n\t\treturn Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);\r\n\t}\r\n\t\r\n\tdegreesToCartographic(longitude: number, latitude: number, height?: number) {\r\n\t\treturn Cesium.Cartographic.fromDegrees(longitude, latitude, height);\r\n\t}\r\n\t\r\n\tradiansToCartographic(longitude: number, latitude: number, height?: number) {\r\n\t\treturn Cesium.Cartographic.fromRadians(longitude, latitude, height);\r\n\t}\r\n\t\r\n\tdegreesToUTM(longitude: number, latitude: number) {\r\n\t\treturn new LatLonEllipsoidal(latitude, longitude).toUtm();\r\n\t}\r\n\t\r\n\tUTMToDegrees(zone: number, hemisphereType: hemisphere, easting: number, northing: number) {\r\n\t\treturn this.geodesyToCesiumObject(new Utm(zone, hemisphereType, easting, northing).toLatLonE());\r\n\t}\r\n\t\r\n\tprivate geodesyToCesiumObject(geodesyRadians: LatLon) {\r\n\t\treturn {\r\n\t\t\tlongitude : geodesyRadians.lon,\r\n\t\t\tlatitude : geodesyRadians.lat,\r\n\t\t\theight : geodesyRadians['height'] ? geodesyRadians['height'] : 0\r\n\t\t};\r\n\t}\r\n\r\n    /**\r\n     * middle point between two points\r\n     * @param first  {latitude,longitude} in radians\r\n     * @param second {latitude,longitude} in radians\r\n     */\r\n\tmidPointToCartesian3(first: { latitude: number, longitude: number }, second: { latitude: number, longitude: number }) {\r\n\t\tconst toDeg = (rad: number) => Cesium.Math.toDegrees(rad);\r\n\t\tconst firstPoint = new LatLonVectors(toDeg(first.latitude), toDeg(first.longitude));\r\n\t\tconst secondPoint = new LatLonVectors(toDeg(second.latitude), toDeg(second.longitude));\r\n\t\tconst middlePoint: any = firstPoint.midpointTo(secondPoint);\r\n\t\t\r\n\t\treturn Cesium.Cartesian3.fromDegrees(middlePoint.lon, middlePoint.lat);\r\n\t}\r\n\r\n  middlePointByScreen(position0: Cartesian3, position1: Cartesian3): Cartesian3 {\r\n\t\tconst scene = this.cesiumService.getScene();\r\n    const screenPosition1 = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position0);\r\n    const screenPosition2 = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position1);\r\n    const middleScreenPoint =\r\n      new Cesium.Cartesian2((screenPosition2.x + screenPosition1.x) / 2.0, (screenPosition2.y + screenPosition1.y) / 2.0);\r\n    return scene.pickPosition(middleScreenPoint);\r\n  }\r\n\r\n    /**\r\n     * initial bearing between two points\r\n     *\r\n     * * @return bearing in degrees\r\n     * @param first - {latitude,longitude} in radians\r\n     * @param second - {latitude,longitude} in radians\r\n     */\r\n\tbearingTo(first: { latitude: number, longitude: number }, second: { latitude: number, longitude: number }) {\r\n\t\tconst toDeg = (rad: number) => Cesium.Math.toDegrees(rad);\r\n\t\tconst firstPoint = new LatLonVectors(toDeg(first.latitude), toDeg(first.longitude));\r\n\t\tconst secondPoint = new LatLonVectors(toDeg(second.latitude), toDeg(second.longitude));\r\n\t\tconst bearing = firstPoint.bearingTo(secondPoint);\r\n\t\t\r\n\t\treturn bearing;\r\n\t}\r\n\r\n    /**\r\n     * initial bearing between two points\r\n     *\r\n     * @return bearing in degrees\r\n     * @param firstCartesian3\r\n     * @param secondCartesian3\r\n     */\r\n\tbearingToCartesian(firstCartesian3: Cartesian3, secondCartesian3: Cartesian3) {\r\n\t\tconst firstCart = Cesium.Cartographic.fromCartesian(firstCartesian3);\r\n\t\tconst secondCart = Cesium.Cartographic.fromCartesian(secondCartesian3);\r\n\t\t\r\n\t\treturn this.bearingTo(firstCart, secondCart);\r\n\t}\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: CesiumService, decorators: [{ type: Optional }, ]},\n];\n}\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}